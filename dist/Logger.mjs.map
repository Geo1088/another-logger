{"version":3,"file":"Logger.mjs","sources":["../src/Logger.ts"],"sourcesContent":["import { format } from 'util';\n\nimport { Transport } from './models/Transport'\nimport { defaultConfig } from './defaults';\nimport { consoleTable } from './fakeConsole';\n\n/** Configuration for a logger. */\nexport interface LoggerConfig {\n\t/**\n\t * An object defining the log levels to use. For each entry, the key is the\n\t * level name, and the value determines which transports are used by the\n\t * level. A value of `true` sends this level to all transports, `false`\n\t * sends the level to no transports (disabling its output), and an object\n\t * value can be used to provide control for individual transports.\n\t */\n\tlevels?: {\n\t\t[name: string]: boolean | {\n\t\t\t/**\n\t\t\t * A list of transport names that this level should be sent to.\n\t\t\t */\n\t\t\tuseTransports?: string[],\n\t\t\t/**\n\t\t\t * A list of transport names that this level should *not* be sent\n\t\t\t * to. If `useTransports` is unset, the level will be sent to all\n\t\t\t * transports except those in this list.\n\t\t\t */\n\t\t\tdisableTransports?: string[],\n\t\t};\n\t};\n\t/**\n\t * An object defining transports usable by the logger. A transport\n\t * represents a target for log messages, e.g. the console or a chat program.\n\t * For each entry in this object, the key is the name of the transport, and\n\t * the value is a transport instance.\n\t */\n\ttransports?: {\n\t\t[name: string]: Transport;\n\t};\n}\n\n/** A function that logs things at a particular level. */\nexport interface LoggerFunction {\n\t/** Sends a message to all transports configured for this level. */\n\t(...contents: any[]): void;\n\t/** Sends a message and include a stack trace. */\n\ttrace(...contents: any[]): void;\n\t/**\n\t * Renders a table with the given input, optionally filtering the rendered\n\t * properties.\n\t */\n\ttable(tabularData: any, properties?: string[]): void;\n}\n\n/** An object with methods for each configured log level. */\n// NOTE: I have no idea why this doesn't work as an interface, but it doesn't\nexport type Logger<LevelName extends keyof any = keyof any> = {\n\t[key in LevelName]: LoggerFunction;\n}\n\n/** Creates a logger from the given configuration. */\n// TODO: is there any way to clean up this signatrure? I'm hesitant to touch it\n//       anymore because the intellisense tooltip it generates is really concise\n//       but if it can be simplified without making Intellisense unreadable then\n//       we should do that.\nexport function createLogger<T extends LoggerConfig>(config: T): Logger<keyof T[\"levels\"] | keyof typeof defaultConfig[\"levels\"]> {\n\t// Create the object we'll fill with logger functions\n\tconst logger = {} as Logger<keyof T[\"levels\"] | keyof typeof defaultConfig[\"levels\"]>;\n\n\t// Apply the config customizations on top of the default config\n\t// TODO: this is not a deep clone. does it need to be?\n\tconfig.levels = Object.assign({}, defaultConfig.levels, config.levels);\n\tconfig.transports = Object.assign({}, defaultConfig.transports, config.transports);\n\t// Because defaultConfig defines both levels and transports, we can now\n\t// guarantee config.levels and config.transports are not undefined, so\n\t// they can be used as config.levels! and config.transports! from now on\n\n\t// Create logger functions for all configured levels and add them\n\tfor (const [levelName, levelOptions] of Object.entries(config.levels)) {\n\t\tlevelName as keyof T[\"levels\"];\n\t\t// Make a list of transports to send messages of this level to\n\t\tlet transports: Transport[];\n\t\tif (levelOptions === true) {\n\t\t\t// all transports\n\t\t\ttransports = [...Object.values(config.transports)];\n\t\t} else if (levelOptions === false) {\n\t\t\t// no transports (level disabled, but log functions still exist)\n\t\t\ttransports = [];\n\t\t} else {\n\t\t\t// set transports based on what's in useTransports/disableTransports\n\t\t\tlet transportNames = levelOptions.useTransports || Object.keys(config.transports);\n\t\t\tif (levelOptions.disableTransports) {\n\t\t\t\ttransportNames = transportNames.filter(name => !levelOptions.disableTransports?.includes(name));\n\t\t\t}\n\t\t\ttransports = transportNames.map(name => config.transports![name]).filter(t => t);\n\t\t}\n\n\t\t// Create the logger functions for this level\n\t\tconst loggerFunc: LoggerFunction = (...contents: any[]) => {\n\t\t\t// send message to all transports configured for this level\n\t\t\ttransports.forEach(transport => transport.sendRaw(contents, levelName, logger));\n\t\t};\n\t\tloggerFunc.trace = (...contents: any[]) => {\n\t\t\tconst stacktrace = new Error().stack!\n\t\t\t\t// Remove the first two lines, leaving a newline as the first char\n\t\t\t\t.replace(/.*\\n.*/, '')\n\t\t\t\t// Remove lines coming from internal modules\n\t\t\t\t.replace(/\\n\\s*at \\S+ \\(internal[\\s\\S]*$/, '');\n\t\t\tloggerFunc(format(...contents) + stacktrace);\n\t\t}\n\t\tloggerFunc.table = (...contents: any[]) => {\n\t\t\tlet tableString = consoleTable(...contents);\n\t\t\t// If the table is multiline, add a newline at the beginning to preserve\n\t\t\t// alignment. `indexOf` check because passing e.g. a number to the table\n\t\t\t// function results in that number being returned, and numbers don't\n\t\t\t// have an `indexOf` method.\n\t\t\tif (typeof tableString === 'string' && tableString.indexOf('\\n') !== -1) {\n\t\t\t\ttableString = `\\n${tableString}`;\n\t\t\t}\n\t\t\tloggerFunc(tableString);\n\t\t}\n\n\t\t// We know levelName is a level key since it came right out of \n\t\t// Object.entries(config.levels) above, Typescript just doesn't know it\n\t\tlogger[levelName as keyof T[\"levels\"]] = loggerFunc;\n\t}\n\n\t// We've now added all levels to the logger, including those from the\n\t// default configuration since we merged that with the given comfiguration\n\t// at the beginning, so it's safe to assert that it has all the same\n\t// properties as this type implies.\n\treturn logger;\n}\n\n/**\n * The default logger. Has levels `debug`, `info`, `success`, `warn`, `error`,\n * and `fatal`, and a transport that sends log messages to the console.\n */\nexport const defaultLogger = createLogger({});\n"],"names":[],"mappings":";;;;AA2DA;AACA;AACA;AACA;AACA;SACgB,YAAY,CAAyB,MAAS;;IAE7D,MAAM,MAAM,GAAG,EAAsE,CAAC;;;IAItF,MAAM,CAAC,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,aAAa,CAAC,MAAM,EAAE,MAAM,CAAC,MAAM,CAAC,CAAC;IACvE,MAAM,CAAC,UAAU,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,aAAa,CAAC,UAAU,EAAE,MAAM,CAAC,UAAU,CAAC,CAAC;;;;;IAMnF,KAAK,MAAM,CAAC,SAAS,EAAE,YAAY,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,MAAM,CAAC,EAAE;;QAGtE,IAAI,UAAuB,CAAC;QAC5B,IAAI,YAAY,KAAK,IAAI,EAAE;;YAE1B,UAAU,GAAG,CAAC,GAAG,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC,CAAC;SACnD;aAAM,IAAI,YAAY,KAAK,KAAK,EAAE;;YAElC,UAAU,GAAG,EAAE,CAAC;SAChB;aAAM;;YAEN,IAAI,cAAc,GAAG,YAAY,CAAC,aAAa,IAAI,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC;YAClF,IAAI,YAAY,CAAC,iBAAiB,EAAE;gBACnC,cAAc,GAAG,cAAc,CAAC,MAAM,CAAC,IAAI,IAAI,CAAC,YAAY,CAAC,iBAAiB,EAAE,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC;aAChG;YACD,UAAU,GAAG,cAAc,CAAC,GAAG,CAAC,IAAI,IAAI,MAAM,CAAC,UAAW,CAAC,IAAI,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;SACjF;;QAGD,MAAM,UAAU,GAAmB,CAAC,GAAG,QAAe;;YAErD,UAAU,CAAC,OAAO,CAAC,SAAS,IAAI,SAAS,CAAC,OAAO,CAAC,QAAQ,EAAE,SAAS,EAAE,MAAM,CAAC,CAAC,CAAC;SAChF,CAAC;QACF,UAAU,CAAC,KAAK,GAAG,CAAC,GAAG,QAAe;YACrC,MAAM,UAAU,GAAG,IAAI,KAAK,EAAE,CAAC,KAAM;;iBAEnC,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC;;iBAErB,OAAO,CAAC,gCAAgC,EAAE,EAAE,CAAC,CAAC;YAChD,UAAU,CAAC,MAAM,CAAC,GAAG,QAAQ,CAAC,GAAG,UAAU,CAAC,CAAC;SAC7C,CAAA;QACD,UAAU,CAAC,KAAK,GAAG,CAAC,GAAG,QAAe;YACrC,IAAI,WAAW,GAAG,YAAY,CAAC,GAAG,QAAQ,CAAC,CAAC;;;;;YAK5C,IAAI,OAAO,WAAW,KAAK,QAAQ,IAAI,WAAW,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE;gBACxE,WAAW,GAAG,KAAK,WAAW,EAAE,CAAC;aACjC;YACD,UAAU,CAAC,WAAW,CAAC,CAAC;SACxB,CAAA;;;QAID,MAAM,CAAC,SAA8B,CAAC,GAAG,UAAU,CAAC;KACpD;;;;;IAMD,OAAO,MAAM,CAAC;AACf,CAAC;AAED;;;;MAIa,aAAa,GAAG,YAAY,CAAC,EAAE;;;;"}